from typing import List, Optional
import decimal
import math
import orderbook

import numpy as np
import pandas as pd

import modules.settings as settings
import modules.trader



class ZeroIntelligence(modules.trader.Trader):
	'''
	ZeroIntelligence arrive according to a Poisson process and trade randomly.
	'''
	def __init__(self, idx: int, quantity_max: int, shading_min: int, shading_max: int,
	default_exchange: str, *args, **kwargs) -> None:
		super(ZeroIntelligence, self).__init__(*args, **kwargs)
		self._idx = idx
		self.quantity_max = quantity_max
		self.utility = []
		self.private_valuation = 0
		self.position = 0
		self.side: int = None
		self.shading_min: int = shading_min
		self.shading_max: int = shading_max
		self.default_exchange = default_exchange


	def __str__(self):
		return(f'ZeroIntelligence trader {self._idx}')


	def __lt__(self, other):
		return self._idx < other._idx


	def get_public_utility_of_the_asset(self) -> decimal.Decimal:
		'''
		Represents equation (1), slightly rewritten.
		'''
		mean_price = self.regulator.asset.mean_price
		return mean_price + (self.regulator.asset.latest_price - mean_price) * \
		(1 - settings.MEAN_REVERSION_FACTOR) ** (settings.SESSION_LENGTH - self.regulator.current_time)


	def generate_private_component_gain(self) -> List[float]:
		'''
		Generates a list of private benfits. Comes from a normal distribution and is used for calculting the order's price 
		at which the trader should submit his order. It is also valuing the position at the end of the trading session.
		'''
		return sorted(np.random.normal(0, settings.SIGMA_UTILITY, 2 * self.quantity_max), reverse = True)


	def get_private_utility_of_the_asset(self) -> float:
		'''
		The private part of the utility depends on two factors, that are the current position that the trader holds
		and whether he is a buyer or a seller. Given that the vector is `2 * self.quantity_max` long, we get to the 
		middle of the list with `self.quantity_max - 1` + the adjustments (that is the position is actually 0).
		'''
		utility_vector = self.generate_private_component_gain()
		return utility_vector[self.quantity_max - 1 + self.side + self.position]


	def generate_offset(self):
		'''
		Given the properties of the uniform distribution, we can compute this part on its own and we'll add (subtract)
		the number from the sum of the public and private valuation if the trader is a seller (buyer).
		'''
		shading = np.random.uniform(self.shading_min, self.shading_max)
		return - shading if self.side else shading


	def decide_direction(self):
		'''
		In the next trade, the trader is either a buyer or a seller, drawn from binomial distribution.
		'''
		self.side = np.random.binomial(1, 0.5)


	def trade(self):
		'''
		The trade function is called every time a trader enters the market according to his poisson process.
		It starts off by calling the asset function which adds a new price into the list of asset's prices.
		After that the trader's side is drawn from a binomial distribution.
		Then trader's public and private component of his valuation are calculated and summed along with
		the generated offset. This sum then equals the order_price which will be used for trading.
		The order is sent and only then we equal the 'current_entry' by one so it corresponds to next entry time
		generated by the poission process.
		'''
		self.regulator.asset.get_new_price()
		self.decide_direction()
		order_price = int(
			self.get_public_utility_of_the_asset() + 
			self.get_private_utility_of_the_asset() +
			self.generate_offset()
		)
		if self.current_order:
			self.delete_order_from_an_exchange(
				exchange_name = self.current_order.exchange_name,
				exchanges = self.regulator.exchanges
			)
		
		exchange_name, order_price = self.decide_what_exchange_and_price_to_choose(
			exchange_name = self.default_exchange,
			order_price = order_price
		)
		action, price = self.process_response_from_exchange(
			exchange_name = exchange_name,
			order_price = order_price
		)
		return self.send_order(
			exchange_name = exchange_name,
			action = action,
			price = price
		)


	def get_national_best_bid_and_offer(self) -> str:
		'''
		Returns the latest orderbook snapshot, which is stored in the Regulator's historic_exchanges_list.
		'''
		return self.get_accurate_national_best_bid_and_offer(
			exchanges = self.regulator.historic_exchanges_list[-1].exchanges,
			current_order = self.current_order,
		)


	def decide_what_exchange_and_price_to_choose(self, exchange_name: str, order_price: int):
		'''
		By default the trader sends his order to the exchange which was assigned to him on initializaiton.
		This function then returns the exchange and price at which the trader is willing to trade, it does not alter
		the direction (long/short) that the trade wants to trade in.
		'''
		side_type = modules.misc.side_to_orderbook_type(not self.side)
		exchanges = self.regulator.historic_exchanges_list[-1].exchanges
		exchange_name = self.default_exchange
		national_best_bid_and_offer = self.get_national_best_bid_and_offer()
		
		# The default exchange does not have to have orders on one side, that is when the OrderSideEmpty exceptions
		# is triggered and instead best_price is the best bid (ask) in case the trader is a seller (buyer).
		try:
			best_price = exchanges[exchange_name].get_side(side_type).get_best().price
		except orderbook.exceptions.OrderSideEmpty:
			best_price = national_best_bid_and_offer.ask if self.side else national_best_bid_and_offer.bid

		if best_price:
			if self.side and national_best_bid_and_offer.ask:
				if order_price >= national_best_bid_and_offer.ask and national_best_bid_and_offer.ask <= best_price:
					exchange_name = national_best_bid_and_offer.ask_exchange
					order_price = national_best_bid_and_offer.ask
			elif not self.side and national_best_bid_and_offer.bid:
				if order_price <= national_best_bid_and_offer.bid and national_best_bid_and_offer.bid >= best_price:
					exchange_name = national_best_bid_and_offer.bid_exchange
					order_price = national_best_bid_and_offer.bid
		return (exchange_name, order_price)


	def process_response_from_exchange(self, exchange_name:str, order_price: int) -> None:
		'''
		We get back the info from the exchange (wrapped by the Regulator object), saying whether our order was executed or added to the orderbook.
		It is also possible that the price updates (if there is a better order in the market).
		'''
		return self.regulator.process_order(
			side = self.side,
			order_price = order_price,
			exchange_name = exchange_name,
		)


	def send_order(self, exchange_name: str, action:str, price: int) -> Optional[int]:
		'''
		The information about the trader's intention (buying/selling at which price) is sent to the regulator and processed.
		Regulator knows of the (delayed) NBBO and therefore returns the exchange, action (adding a limit order or executing a
		resting order). If the trade is executed, the function returns the ID of the trader whose order has been executed.
		'''
		self.current_order = None
		if action == 'A':
			nanoseconds, seconds = math.modf(self.regulator.current_time)
			self.add_limit_order(
				price = price, 
				seconds = seconds,
				nanoseconds = nanoseconds,
				exchange_name = exchange_name
			)
		else:
			return self.execute_order(
				exchange_name = exchange_name
			)
		return None


	def calculate_total_payoff(self) -> int:
		'''
		At the end of trading this function sums the total payoff which consists of the closed trades (Profit or Loss)
		and of the open position, valued at the current price, adjusted for private benefits.
		'''
		payoff: int = 0
		side = 1 if np.sign(self.position) > 0 else 0
		if len(self.trades):
			trades_dataframe = pd.DataFrame(self.trades)[['side', 'price']]
			trades_dataframe['side'] = trades_dataframe['side'].replace(0, -1)
			trades_dataframe = trades_dataframe.sort_values(by = ['side'], ascending = side)
			if self.position:
				remaining_trades_dataframe = trades_dataframe[-abs(self.position):]
				trades_dataframe = trades_dataframe[:-abs(self.position)]
			payoff += sum(trades_dataframe['side'] * trades_dataframe['price'])
		if self.position:
			payoff += sum([
			 	trade - self.regulator.asset.latest_price
			 	for trade in remaining_trades_dataframe['price']
			]) * self.position
			# Again we need to adjust the position in the
			if side > 0:
				lower_bound = self.quantity_max - 1 + side
				upper_bound = lower_bound + self.position
			else:
				upper_bound = self.quantity_max - 1 + side
				lower_bound = upper_bound + self.position

			payoff += sum(self.generate_private_component_gain()[lower_bound:upper_bound])
		return payoff
