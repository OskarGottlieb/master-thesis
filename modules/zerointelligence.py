from typing import List, Optional
import decimal
import math
import orderbook

import numpy as np
import pandas as pd

import modules.settings as settings
import modules.trader



class ZeroIntelligence(modules.trader.Trader):
	'''
	ZeroIntelligence arrive according to a Poisson process and trade randomly.
	'''
	def __init__(self, idx: int, quantity_max: int, shading_min: int, shading_max: int,
	default_exchange = orderbook.orderbook.NonUniqueIdOrderBook, *args, **kwargs) -> None:
		super(ZeroIntelligence, self).__init__(*args, **kwargs)
		self._idx = idx
		self.quantity_max = quantity_max
		self.utility = []
		self.private_valuation = 0
		self.position = 0
		self.side: int = None
		self.shading_min: int = shading_min
		self.shading_max: int = shading_max
		self._default_exchange = default_exchange


	def __str__(self):
		return(f'ZeroIntelligence trader {self._idx}')


	def __lt__(self, other):
		return self._idx < other._idx


	def get_public_utility_of_the_asset(self, timestamp: float) -> decimal.Decimal:
		'''
		Represents equation (1), slightly rewritten.
		'''
		mean_price = self.regulator.asset.mean_price
		return mean_price + (self.regulator.asset.latest_price - mean_price) * \
		(1 - settings.MEAN_REVERSION_FACTOR) ** (settings.SESSION_LENGTH - timestamp)


	def generate_private_component_gain(self) -> List[float]:
		'''
		Generates a list of private benfits. Comes from a normal distribution and is used for calculting the order's price 
		at which the trader should submit his order. It is also valuing the position at the end of the trading session.
		'''
		return sorted(np.random.normal(0, settings.SIGMA_UTILITY, 2 * self.quantity_max), reverse = True)


	def get_private_utility_of_the_asset(self) -> float:
		'''
		The private part of the utility depends on two factors, that are the current position that the trader holds
		and whether he is a buyer or a seller. Given that the vector is `2 * self.quantity_max` long, we get to the 
		middle of the list with `self.quantity_max - 1` + the adjustments (that is the position is actually 0).
		'''
		utility_vector = self.generate_private_component_gain()
		return utility_vector[self.quantity_max - 1 + self.side + self.position]


	def generate_offset(self):
		'''
		Given the properties of the uniform distribution, we can compute this part on its own and we'll add (subtract)
		the number from the sum of the public and private valuation if the trader is a seller (buyer).
		'''
		shading = np.random.uniform(self.shading_min, self.shading_max)
		return - shading if self.side else shading


	def decide_direction(self):
		'''
		In the next trade, the trader is either a buyer or a seller, drawn from binomial distribution.
		'''
		self.side = np.random.binomial(1, 0.5)


	def trade(self, timestamp: float):
		'''
		The trade function is called every time a trader enters the market according to his poisson process.
		It starts off by calling the asset function which adds a new price into the list of asset's prices.
		After that the trader's side is drawn from a binomial distribution.
		Then trader's public and private component of his valuation are calculated and summed along with
		the generated offset. This sum then equals the order_price which will be used for trading.
		The order is sent and only then we equal the 'current_entry' by one so it corresponds to next entry time
		generated by the poission process.
		'''
		self.regulator.asset.get_new_price()
		self.decide_direction()
		order_price = int(
			self.get_public_utility_of_the_asset(timestamp) + 
			self.get_private_utility_of_the_asset() +
			self.generate_offset()
		)
		self.delete_order()
		return self.send_order(order_price, timestamp)


	def send_order(self, order_price: int, timestamp: float) -> Optional[int]:
		'''
		The information about the trader's intention (buying/selling at which price) is sent to the regulator and processed.
		Regulator knows of the (delayed) NBBO and therefore returns the exchange, action (adding a limit order or executing a
		resting order). If the trade is executed, the function returns the ID of the trader whose order has been executed.
		'''
		exchange, action, price = self.regulator.process_order(
			side = self.side,
			order_price = order_price,
			timestamp = timestamp,
			default_exchange = self._default_exchange,
		)
		if action == 'A':
			seconds, nanoseconds = math.modf(timestamp)
			self.add_limit_order(
				price = price, 
				seconds = seconds,
				nanoseconds = nanoseconds,
				exchange = exchange
			)
		else:
			return self.execute_order(
				exchange = exchange
			)
		return None


	def calculate_total_payoff(self) -> int:
		'''
		At the end of trading this function sums the total payoff which consists of the closed trades (Profit or Loss)
		and of the open position, valued at the current price, adjusted for private benefits.
		'''
		payoff: int = 0
		side = 1 if np.sign(self.position) > 0 else 0
		if len(self.trades):
			trades_dataframe = pd.DataFrame(self.trades)[['side', 'price']]
			trades_dataframe['side'] = trades_dataframe['side'].replace(0, -1)
			trades_dataframe = trades_dataframe.sort_values(by = ['side'], ascending = side)
			if self.position:
				remaining_trades_dataframe = trades_dataframe[-abs(self.position):]
				trades_dataframe = trades_dataframe[:-abs(self.position)]
			payoff += sum(trades_dataframe['side'] * trades_dataframe['price'])
		if self.position:
			payoff += sum([
			 	trade - self.regulator.asset.latest_price
			 	for trade in remaining_trades_dataframe['price']
			]) * self.position
			# Again we need to adjust the position in the
			if side > 0:
				lower_bound = self.quantity_max - 1 + side
				upper_bound = lower_bound + self.position
			else:
				upper_bound = self.quantity_max - 1 + side
				lower_bound = upper_bound + self.position

			payoff += sum(self.generate_private_component_gain()[lower_bound:upper_bound])
		return payoff