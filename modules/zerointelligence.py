from typing import List, Optional, Tuple
import decimal
import math
import orderbook

import numpy as np
import pandas as pd

import modules.settings as settings
import modules.trader



class ZeroIntelligence(modules.trader.Trader):
	'''
	ZeroIntelligence arrive according to a Poisson process and trade randomly.
	'''
	def __init__(self, quantity_max: int, shading_min: int, shading_max: int,
	default_exchange: str, *args, **kwargs) -> None:
		super(ZeroIntelligence, self).__init__(*args, **kwargs)
		self.quantity_max = quantity_max
		self.utility = []
		self.shading_min: int = shading_min
		self.shading_max: int = shading_max
		self.default_exchange = default_exchange
		self.list_private_utility: List[float] = []


	def generate_private_component_gain(self) -> List[float]:
		'''
		Generates a list of private benfits. Comes from a normal distribution and is used for calculting the order's price 
		at which the trader should submit his order. It is also valuing the position at the end of the trading session.
		'''
		return sorted(np.random.normal(0, settings.SIGMA_UTILITY, 2 * self.quantity_max), reverse = True)


	def get_private_utility_of_the_asset(self) -> float:
		'''
		The private part of the utility depends on two factors, that are the current position that the trader holds
		and whether he is a buyer or a seller. Given that the vector is `2 * self.quantity_max` long, we get to the 
		middle of the list with `self.quantity_max - 1` + the adjustments of side and position.
		'''
		utility_vector = self.generate_private_component_gain()
		# We save the value into an object attribute, as we will need it when calculating the surplus.
		self.private_utility = utility_vector[self.quantity_max - 1 + self.side + self.position]
		return self.private_utility


	def generate_offset(self):
		'''
		Given the properties of the uniform distribution, we can compute this part on its own and we'll add (subtract)
		the number from the sum of the public and private valuation if the trader is a seller (buyer).
		'''
		shading = np.random.uniform(self.shading_min, self.shading_max)
		return - shading if self.side else shading


	def decide_direction(self):
		'''
		In the next trade, the trader is either a buyer or a seller, drawn from binomial distribution.
		'''
		self.side = np.random.binomial(1, 0.5)


	def do(self):
		'''
		The do function is called every time a trader enters the market according to his poisson process.
		It starts off by calling the asset function which adds a new price into the list of asset's prices.
		After that the trader's side is drawn from a binomial distribution.
		Then trader's public and private component of his valuation are calculated and summed along with
		the generated offset. This sum then equals the order_price which will be used for trading.
		The order is sent and only then we equal the 'current_entry' by one so it corresponds to next entry time
		generated by the poission process.
		'''
		self.decide_direction()
		limit_price = int(
			self.get_estimate_of_the_fundamental_value_of_the_asset() + 
			self.get_private_utility_of_the_asset() +
			self.generate_offset()
		)
		if self.current_orders:
			for order in self.current_orders:
				self.delete_order_from_an_exchange(
					order = order,
					exchange_name = order.exchange_name,
					exchanges = self.regulator.exchanges,
				)
		self.current_orders = []

		self.send_order_to_the_exchange(
			side = self.side,
			exchange_name = self.decide_what_exchange_and_price_to_choose(limit_price = limit_price),
			limit_price = limit_price
		)


	def decide_what_exchange_and_price_to_choose(self, limit_price: int) -> str:
		'''
		By default the trader sends his order to the exchange which was assigned to him on initializaiton.
		This function then returns the exchange and price at which the trader is willing to trade, it does not alter
		the direction (long/short) that the trade wants to trade in.
		'''
		side_type = modules.misc.side_to_orderbook_type(not self.side)
		exchanges = self.regulator.historic_exchanges_list[-1].exchanges
		exchange_name = self.default_exchange
		national_best_bid_and_offer = self.get_national_best_bid_and_offer()
		
		# The default exchange does not have to have orders on one side, that is when the OrderSideEmpty exceptions
		# is triggered and instead best_price is the best bid (ask) in case the trader is a seller (buyer).
		try:
			best_price = exchanges[exchange_name].get_side(side_type).get_best().price
		except orderbook.exceptions.OrderSideEmpty:
			best_price = national_best_bid_and_offer.ask if self.side else national_best_bid_and_offer.bid
		if best_price:
			if self.side and national_best_bid_and_offer.ask:
				if limit_price >= national_best_bid_and_offer.ask and national_best_bid_and_offer.ask <= best_price:
					exchange_name = national_best_bid_and_offer.ask_exchange
			elif not self.side and national_best_bid_and_offer.bid:
				if limit_price <= national_best_bid_and_offer.bid and national_best_bid_and_offer.bid >= best_price:
					exchange_name = national_best_bid_and_offer.bid_exchange
		return exchange_name


	def calculate_total_surplus(self) -> int:
		'''
		At the end of trading this function sums the total payoff which consists of the closed trades (Profit or Loss)
		and of the open position, valued at the current price, adjusted for private benefits.
		'''
		payoff = self.calculate_profit_from_trading()
		payoff += self.calculate_value_of_final_position()
		payoff += sum(self.list_private_utility)
		return payoff
		
